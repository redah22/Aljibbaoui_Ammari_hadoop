\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\title{Projet MapReduce}
\author{Tala Aljibbaoui et Reda Ammari}
\date{November 2025}

\begin{document}

\maketitle

%\section{Introduction}

\section*{Exercice 0 - WordCount}
On voyons une longue liste de mots triés avec le nombre de fois qu'ils apparaissent. On remarque aussi que les nombres ou les signes de ponctuation ressortent parce qu’ils sont considérés comme des “mots” par le programme.



\section*{Exercice 1 - WordCount + Filter}


\begin{enumerate}
    \item Dans Reduce, on ajoute une condition if $\,\text{if } (\,\text{sum} \geq 10\,)$ dans le bloc :
     context.write(key, new IntWritable(sum));
   
    \item On a implémenté un regex pour filtrer les ponctuations.
     On a aussi inclut les accents, parceque sinon le regex allait les filtrer aussi.
    
    \item le mot "Article" est le plus fréquent, il apparait 170 fois.
    
\end{enumerate}




\section*{Exercice 2 - Group-By}

Dans le mapper, on a choisi d’utiliser split(",") pour découper chaque ligne (avec value.toString()) du fichier superstore.csv. 
%Ensuite, comme certaines lignes peuvent être vides, on a mis une petite condition pour les ignorer directement.

Ça nous donne un tableau columns dans lequel chaque case correspond à une colonne du CSV.

Ensuite, on a extrait l’attribut Customer-ID et le Profit dans le tableau obtenu.
Après ça, on a envoyé ces deux informations au contexte :
la clé = le Customer-ID,

et la valeur = le profit converti en DoubleWritable.

C’est ce qui permet à Hadoop de regrouper automatiquement les lignes par client.





\section*{Exercice 3 - Group-By (Analyses avancées)}

Pour ce dernier exercice, l'objectif était un peu plus complexe : pour chaque commande (\textit{Order ID}), il fallait réussir à calculer à la fois le nombre de produits différents achetés et le nombre total d'articles.

\begin{enumerate}
    \item \textbf{Le problème du Mapper :} On ne peut envoyer qu'une seule valeur par clé au Reducer. Or, on avait besoin de deux infos : l'ID du produit (pour compter les doublons) et la quantité (pour la somme).
    
    \item \textbf{La solution :} Dans le Map, on a "tricoté" les deux informations ensemble dans une seule chaîne de caractères, séparées par un point-virgule (ex : \texttt{"Produit123;5"}).
    
    \item \textbf{La logique du Reduce :} 
    \begin{itemize}
        \item Pour compter les produits uniques, on a utilisé un \texttt{HashSet} en Java. C'est très pratique car cette structure refuse les doublons. On a juste eu à regarder la taille du Set à la fin.
        \item Pour le nombre d'articles, on a découpé notre chaîne pour récupérer la partie "quantité" et on a fait une addition classique.
    \end{itemize}

    \item \textbf{Configuration :} On a dû modifier le \texttt{main} pour dire à Hadoop que la sortie finale n'était plus un nombre à virgule (\texttt{DoubleWritable}), mais du texte (\texttt{Text}), car on affiche une phrase de résumé pour chaque commande.
    
\end{enumerate}


\section*{Exercice 4 - Join}

L'objectif de cet exercice est de réaliser une jointure de type \textit{Reduce-Side Join} pour associer des clients à leurs commentaires de commande. Le but est de produire des paires \texttt{(Nom du client, Commentaire de la commande)}.

Face à la complexité du format des fichiers \texttt{.tbl} (séparateur \texttt{|}, présence de ce même caractère dans les commentaires), une approche robuste avec \texttt{MultipleInputs} a été choisie.

\begin{enumerate}
    \item \textbf{Logique des Mappers :}
    Deux Mappers distincts ont été créés, un pour chaque fichier, afin de gérer leurs structures spécifiques :
    \begin{itemize}
        \item \textbf{CustomerMapper :} Lit \texttt{customers.tbl}. Il extrait le \texttt{CustomerID} (colonne 0) et le nom (colonne 1). Il émet \texttt{(CustomerID, "CUST\#" + CustomerName)}.
        \item \textbf{OrderMapper :} Lit \texttt{orders.tbl}. Il extrait le \texttt{CustomerID} (colonne 1). Une attention particulière a été portée à la reconstruction du commentaire (colonne 8), car celui-ci pouvait contenir des \texttt{|}. Il émet \texttt{(CustomerID, "ORDER\#" + OrderComment)}.
    \end{itemize}
    Dans les deux cas, la méthode \texttt{split("\\|", -1)} a été cruciale pour gérer correctement le séparateur \texttt{|} et conserver les colonnes vides.
    
    \item \textbf{Logique du Reducer :}
    Le Reducer reçoit les données groupées par \texttt{CustomerID}. Comme pour l'approche classique, nous avons utilisé des listes temporaires pour effectuer la jointure :
    \begin{itemize}
        \item Deux listes sont créées : une pour les noms (\texttt{customerNames}) et une pour les commentaires (\texttt{orderComments}).
        \item En parcourant les valeurs reçues, nous les trions dans la liste appropriée en fonction de leur préfixe (\texttt{CUST\#} ou \texttt{ORDER\#}).
        \item Enfin, deux boucles imbriquées parcourent ces deux listes pour générer toutes les combinaisons possibles de paires \texttt{(nom, commentaire)}, qui sont ensuite écrites dans le contexte de sortie.
    \end{itemize}
    Cette méthode assure que si un client a passé plusieurs commandes, son nom sera associé à chacun des commentaires.
\end{enumerate}


\end{document}
